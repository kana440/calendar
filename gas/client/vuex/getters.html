<script>
const getters = {
  floors(state) {
    return state.rooms.map(room => room.floor).filter((value, index, self) => {
      return self.indexOf(value) === index
    })
  },
  validRooms(state) {
    return state.rooms.filter(room => {
      return room.floor === state.user.floor
      && room.validFrom <= state.selectedDate
      && room.validTo >= state.selectedDate
    })
  },
  calendarEventsSelectedDate(state){
    return state.calendarEvents.find(
      events=>equalDate(events.date, state.selectedDate)
    )
  },
  roomsEventsSelectedDate(state){
    return state.roomsEvents.filter(
      events=>equalDate(events.date, state.selectedDate)
    )
  },
  myWatchList(state){
    return state.watchList.filter(record => (
      record.status === "01_ウォッチ中"　
      && record.subscriber === state.user.email
    ))
  },
  roomsStatus2(state,getters){
    return getters.roomsEventsSelectedDate.map(roomEvents=>{
      switch (roomEvents.response){
        case 'has events': {
          const events = roomEvents.items
          const cells = getters.periods.map(period=>{
            const status = {busy:[], accepted:[], declined:[]}
            events.forEach(event=>{
              const result = getRoomStatus(event,roomEvents.calendarId,state.user.email,period.from,period.to)
              if(result!=='ignore') status[result].push(event)
            })
            return status
          })
          return {
            calendarId: roomEvents.calendarId,
            status: 'has events',
            items: roomEvents.items,
            cells: cells,
          }
        }
        case 'has no events': {
          return {
            calendarId: roomEvents.calendarId,
            status: 'has no events',
          }
        }
        case 'access denied':{
          return {
            calendarId: roomEvents.calendarId,
            status: 'access denied',
          }
        }
      }
  })
  },
  periods(state){
    const hoursFrom = state.periodSetting.hoursFrom
    const hoursTo = state.periodSetting.hoursTo
    const interval = state.periodSetting.interval
    const periods = []
    const time = new Date(state.selectedDate)
    time.setHours(hoursFrom)
    for(let i=hoursFrom; i<hoursTo; i+=interval){
      let from = new Date(time)
      time.setMinutes(time.getMinutes()+interval*60)
      let to = new Date(time)
      periods.push({from,to})
    }
    return periods
  },
  roomsStatus(state, getters){
    return getters.validRooms.map(room=>{
      const roomsEvents = getters.roomsEventsSelectedDate.find(event=>room.calendarId===event.calendarId)
      if(!roomsEvents || !state.selectedDate || roomsEvents.length===0) return {room:room, events:[]}
      return getters.periods.map(period=>{
        const events = roomsEvents.items
        .filter(event=>{
          return (
            (period.from.getTime()) < event.endTime.getTime()
            && (period.to.getTime()) > event.startTime.getTime()
            )
      })
        .filter(event=>{
          if(!event.attendees) return true
          const self = event.attendees.find(attendee=>{
            return attendee.email === event.calendarId
          })
          if(!self || self.responseStatus !== 'declined') return true
          return false
      })
      return {hour: period.from.getHours(), num: events.length, events:events}
    })
  })
  },
}
</script>
